name: "ðŸ’¬ Otron Agent"

on:
  issues:
    types: [opened, edited, labeled]
  pull_request:
    branches: [main]
    types: [opened, edited, labeled, ready_for_review, reopened]
  issue_comment:
    types: [created]
  pull_request_review_comment:
    types: [created]
  pull_request_review:
    types: [submitted]

jobs:
  otron-agent:
    # This `if` check provides complex filtering logic to avoid running Codex
    # on every PR. Admittedly, one thing this does not verify is whether the
    # sender has write access to the repo: that must be done as part of a
    # runtime step.
    #
    # Note the label values should match the ones in the .github/codex/labels
    # folder.
    if: |
      (github.event_name == 'issues' && (
        (github.event.action == 'labeled' && (
          github.event.label.name == 'codex-attempt' ||
          github.event.label.name == 'codex-triage' ||
          github.event.label.name == 'codex-review' ||
          github.event.label.name == 'codex-rust-review' ||
          github.event.label.name == 'otron:work' ||
          github.event.label.name == 'otron:review' ||
          github.event.label.name == 'otron:research'
        )) ||
        contains(github.event.issue.body, '@otron-agent')
      )) ||
      (github.event_name == 'pull_request' && (
        (github.event.action == 'labeled' && (
          github.event.label.name == 'codex-attempt' ||
          github.event.label.name == 'codex-review' ||
          github.event.label.name == 'codex-rust-review' ||
          github.event.label.name == 'otron:work' ||
          github.event.label.name == 'otron:review' ||
          github.event.label.name == 'otron:research'
        )) ||
        contains(github.event.pull_request.body || '', '@otron-agent')
      )) ||
      (github.event_name == 'issue_comment' && github.event.action == 'created' && contains(github.event.comment.body, '@otron-agent')) ||
      (github.event_name == 'pull_request_review_comment' && github.event.action == 'created' && contains(github.event.comment.body, '@otron-agent')) ||
      (github.event_name == 'pull_request_review' && github.event.action == 'submitted' && contains(github.event.review.body, '@otron-agent'))
    runs-on: ubuntu-latest
    permissions:
      contents: write # can push or create branches
      issues: write # for comments + labels on issues/PRs
      pull-requests: write # for PR comments/labels
    steps:
      # TODO: Consider adding an optional mode (--dry-run?) to actions/codex
      # that verifies whether Codex should actually be run for this event.
      # (For example, it may be rejected because the sender does not have
      # write access to the repo.) The benefit would be two-fold:
      # 1. As the first step of this job, it gives us a chance to add a reaction
      #    or comment to the PR/issue ASAP to "ack" the request.
      # 2. It saves resources by skipping the clone and setup steps below if
      #    Codex is not going to run.

      - name: Generate GitHub App Token
        id: generate_token
        env:
          OTRON_APP_ID_VAL: ${{ secrets.OTRON_APP_ID }}
          OTRON_APP_KEY_VAL: ${{ secrets.OTRON_APP_PRIVATE_KEY }}
        if: ${{ env.OTRON_APP_ID_VAL != '' && env.OTRON_APP_KEY_VAL != '' }}
        uses: actions/create-github-app-token@df432ceedc7162793a195dd1713ff69aefc7379e
        with:
          app-id: ${{ env.OTRON_APP_ID_VAL }}
          private-key: ${{ env.OTRON_APP_KEY_VAL }}

      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ steps.generate_token.outputs.token || secrets.GITHUB_TOKEN }}
          fetch-depth: 0
          # If this is a PR event, check out the PR head repo/ref so pushes go to the right place
          repository: ${{ github.event.pull_request.head.repo.full_name || github.repository }}
          ref: ${{ github.event.pull_request.head.ref || github.ref }}
          persist-credentials: true

      - name: Ensure PR head branch is checked out (handles PR comments too)
        shell: bash
        env:
          GH_TOKEN: ${{ steps.generate_token.outputs.token || secrets.GITHUB_TOKEN }}
          TOKEN: ${{ steps.generate_token.outputs.token || secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          EVENT_PATH="$GITHUB_EVENT_PATH"
          IS_PR=$(jq -r 'has("pull_request")' "$EVENT_PATH")
          HEAD_REF=""
          HEAD_REPO=""

          if [[ "$IS_PR" == "true" ]]; then
            HEAD_REF=$(jq -r '.pull_request.head.ref' "$EVENT_PATH")
            HEAD_REPO=$(jq -r '.pull_request.head.repo.full_name' "$EVENT_PATH")
          else
            # For issue_comment events on PRs, resolve PR details via API
            HAS_PR=$(jq -r 'try .issue.pull_request // empty | type' "$EVENT_PATH" || true)
            if [[ "$HAS_PR" == "object" ]]; then
              PR_NUMBER=$(jq -r '.issue.number' "$EVENT_PATH")
              PR_JSON=$(gh api "/repos/${GITHUB_REPOSITORY}/pulls/${PR_NUMBER}")
              HEAD_REF=$(echo "$PR_JSON" | jq -r '.head.ref')
              HEAD_REPO=$(echo "$PR_JSON" | jq -r '.head.repo.full_name')
            fi
          fi

          if [[ -z "$HEAD_REF" || -z "$HEAD_REPO" ]]; then
            echo "No PR head context detected; keeping current checkout."
            exit 0
          fi

          echo "Ensuring head branch '${HEAD_REPO}:${HEAD_REF}' is checked out"
          git config --global advice.detachedHead false
          git remote -v

          if [[ "$HEAD_REPO" == "$GITHUB_REPOSITORY" ]]; then
            git fetch --no-tags origin "$HEAD_REF"
            git checkout -B "$HEAD_REF" "origin/${HEAD_REF}" || git checkout -B "$HEAD_REF"
          else
            # Fork: ensure authenticated remote to the fork exists
            git remote remove pr 2>/dev/null || true
            git remote add pr "https://x-access-token:${TOKEN}@github.com/${HEAD_REPO}.git"
            git fetch --no-tags pr "$HEAD_REF"
            git checkout -B "$HEAD_REF" "pr/${HEAD_REF}" || git checkout -B "$HEAD_REF"
          fi

          echo "Checked out branch: $(git rev-parse --abbrev-ref HEAD)"
          git status -sb

      - name: Determine intent (work/review/research/auto)
        id: intent
        uses: actions/github-script@v7
        with:
          script: |
            const issue = context.payload.issue || null;
            const pr = context.payload.pull_request || null;
            const comment = context.payload.comment || null;
            const review = context.payload.review || null;
            const reviewComment = context.payload.review_comment || null;

            const labels = [
              ...(issue?.labels || []),
              ...(pr?.labels || []),
            ].map(l => typeof l === 'string' ? l : l.name);

            const body = (
              issue?.body || pr?.body || comment?.body || review?.body || reviewComment?.body || ''
            ) || '';

            const has = (name) => labels.includes(name);

            let intent = '';
            if (has('otron:work') || has('codex-attempt') || has('codex-triage')) intent = 'work';
            else if (has('otron:review') || has('codex-review') || has('codex-rust-review')) intent = 'review';
            else if (has('otron:research')) intent = 'research';
            else if (body.includes('@otron-agent')) intent = 'auto';

            core.setOutput('intent', intent);

      - name: Export intent as env
        if: ${{ steps.intent.outputs.intent != '' }}
        run: echo "OTRON_INTENT=${{ steps.intent.outputs.intent }}" >> $GITHUB_ENV

      - name: Compute codex args per intent
        id: args
        uses: actions/github-script@v7
        with:
          script: |
            const intent = '${{ steps.intent.outputs.intent }}';
            let args = '--config hide_agent_reasoning=true --full-auto';
            if (intent === 'review' || intent === 'research') {
              args = '--config hide_agent_reasoning=true --no-edit';
            }
            core.setOutput('codex_args', args);

      - uses: dtolnay/rust-toolchain@1.88
        with:
          targets: x86_64-unknown-linux-gnu
          components: clippy

      - uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/bin/
            ~/.cargo/registry/index/
            ~/.cargo/registry/cache/
            ~/.cargo/git/db/
            ${{ github.workspace }}/codex-rs/target/
          key: cargo-ubuntu-24.04-x86_64-unknown-linux-gnu-${{ hashFiles('**/Cargo.lock') }}

      # Note it is possible that the `verify` step internal to Run Codex will
      # fail, in which case the work to setup the repo was worthless :(
      - name: Run Otron Agent
        uses: ./.github/actions/codex
        with:
          openai_api_key: ${{ secrets.OPENAI_API_KEY }}
          github_token: ${{ steps.generate_token.outputs.token || secrets.GITHUB_TOKEN }}
          codex_home: ./.github/codex/home
          trigger_phrase: "@otron-agent"
          codex_args: ${{ steps.args.outputs.codex_args }}
        env:
          OTRON_INTENT: ${{ env.OTRON_INTENT }}
